"""
Check and download applications' updates if any.

Usage
appdownload.py [-h] [-c | -d | -t] [--version]

optional arguments:
  -h, --help            show this help message and exit
  -c, --checkonly       check and report if applications' updates are
                        available without download it
  -d, --download        download applications' updates based on the last build
                        catalog (useful to recover a crashed application
                        storage)
  -m, --make            make applist files based on the last build
                        catalog (useful to make applist files after a
                        configuration modification)
  -t, --testconf        check an appdownload.ini configuration file for
                        internal correctness
  --configfile CONFIGFILE
                        The file specified contains the configuration details.
                        The information in this file includes application
                        catalog. See appdownload.example.ini for more
                        information.
                        The default configuration file name is 'appdownload.ini'
                        located in the current working directory.
  --version             show program's version number and exit

Exit code
  0: no error
  1: an error occurred (error messages are print on stderr stream console
     and write in a log file.
  2: invalid argument. An argument of the command line isn't valid (see Usage).

Environment variables
The following environment variables affect the execution of this script:
TODO
"""
# TODO add a regex field in applist
# add a field in the applist which to contain a regex string for the
# searching of installed application. The display name wil be used only in log.
# add this field as a property of BaseProduct Class (see cots.core)

# TODO add a step to validate the deployment
# a product may be in Pulled or Remote (an update is available), Fetched (update
#  was downloaded and ready to deployed), Deployed.
# add a method to validate the update (at this time, the method validate
# all products)
# maybe an interactive session with ok or not from the user (optional) like
# a quiet option....
#   -q, --quiet disable confirmation in the deployment validation step
#   -d, --deploy validate each product update to be deployed. By default, the
#                user manually validate each product in interactive mode in the
#                console, execpt if the quiet option is selected (see -q)
# change -c (resp. -d) to -p for pull (resp. -f for fetch)

# TODO use exception catching instead of test
# review exception
#  - use TypeError for type mismatch
#  - use KeyError or Value Error for bas value
#  - catch exception instead of testing value before reading a dict value
#  (a['unknown']
#  because the test is done inside the method.

# TODO use shutil.get_terminal_size() for the progress bar

import io
import os.path
import datetime
import argparse
import configparser
import importlib
import logging
import logging.config
import json

from cots import core
from cots import report


__author__ = "Frederic MEZOU"
__version__ = "0.1.0-dev"
__license__ = "GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007"


# Sections and keys names used in the configuration file (see appdownload.ini)
_CORE_SNAME = "core"
_STORE_KNAME = "store"
_LOGGER_KNAME = "logger"
_PULL_REPORT_KNAME = "pulling_report"
_FETCH_REPORT_KNAME = "fetching_report"
_DEPLOY_REPORT_KNAME = "deploying_report"

_APPS_SNAME = "applications"
_INSTALL_KNAME = "install"
_MODULE_KNAME = "module"
_PACKAGE_NAME = "cots"
_PATH_KNAME = "path"
_SET_KNAME = "set"

_SETS_SNAME = "sets"

# Sections and keys names used in the catalog file (see catalog.json)
_CATALOG_FNAME = "catalog.json"
_CAT_WARNING_KNAME = "__warning__"
_CAT_WARNING = \
    "This file is automatically generated, and must not be manually modified. "\
    "It contains the applications database and specifies for each application "\
    "its properties. Appdownload script uses this database to build the "\
    "applist files used by appdeploy script."
_CAT_VERSION_KNAME = "__version__"
_CAT_VERSION = "0.1.0"
_CAT_PRODUCTS_KNAME = "products"
_CAT_ORIGIN_KNAME = "origin"
_CAT_DEPLOYED_KNAME = "deployed"
_CAT_MODIFIED_KNAME = "modified"

_PROD_NAME_KNAME = "display_name"
_PROD_VERSION_KNAME = "version"
_PROD_TARGET_KNAME = "target"
_PROD_INSTALLER_KNAME = "installer"
_PROD_SILENT_INSTALL_ARGS_KNAME = "silent_inst_args"

# APPLIST files
_APPLIST_SEP = ";"
_APPLIST_PREFIX = "applist-"
_APPLIST_EXT = ".txt"

# To make the module as versatile as possible, an nullHandler is added.
# see 'Configuring Logging for a Library'
# docs.python.org/3/howto/logging.html#configuring-logging-for-a-library
_logger = logging.getLogger(__name__)
_logger.addHandler(logging.NullHandler())


class Error(Exception):
    """Base class for AppDownload exceptions."""
    def __init__(self, message=""):
        """
        Constructor.

        Parameters
            :param message: is the message explaining the reason of the
            exception raise.
        """
        self.message = message

    def __str__(self):
        return self.message


class ConfigurationError(Error):
    """
    Raised when a key or a value is erroneous in a configuration file.
    """
    def __init__(self, filename, message, solution=""):
        """
        Constructor.

        Parameters
        :param filename: is the path name (full or partial) of the configuration
        file.
        :param message: is a string detailing the error.
        :param solution: is a recommendation to solve the error.
        """
        msg = "Configuration error in '{}': {} {}"
        Error.__init__(self, msg.format(filename, message, solution))
        self.filename = filename
        self.message = message
        self.solution = solution


class AppDownload:
    """
    Application class.

    Public instance variables
        None

    Public methods
        None

    Subclass API variables (i.e. may be use by subclass)
        None

    Subclass API Methods (i.e. must be overwritten by subclass)
        None
    """

    def __init__(self, config_file):
        """
        Constructor.

        Parameters
            :param config_file: is the name of the configuration file. It may
            be a partial or a full path.
        """
        # check parameters type
        if not isinstance(config_file, io.TextIOBase):
            msg = "config_file argument must be a class 'io.TextIOBase'. " \
                  "not {0}"
            msg = msg.format(config_file.__class__)
            raise TypeError(msg)

        # initialise the configuration based on ConfigParser module.
        self._config = configparser.ConfigParser(
            interpolation=configparser.ExtendedInterpolation())
        self._checked_config = False
        self._config_file = config_file
        self._pulling_report = None
        self._fetching_report = None
        self._deploying_report = None

        # initialise the application catalog.
        self._catalog_filename = ""
        self._catalog = {}
        self._app_set_file = {}

        # a_report
        self._report = ""

        msg = "Instance of {} created <- {}"
        _logger.debug(msg.format(self.__class__, config_file))

    def run(self):
        """
        Run the AppDownload application.

        Parameters
            None
        """
        self._load_config()
        _logger.info("Starting Appdownload (%s)", __version__)
        self._read_catalog()
        self._check_update()
        self._fetch_update()
        self._write_catalog()
        self._write_applist()
        _logger.info("Appdownload (%s) completed.", __version__)

    def check(self):
        """
        Check and a_report if applications' updates are available without
        download it.

        Parameters
            None
        """
        self._load_config()
        _logger.info("Starting Appdownload (%s), check and a_report if "
                     "applications' updates are available.", __version__)
        self._read_catalog()
        self._check_update()
        self._write_catalog()
        _logger.info("Appdownload (%s) completed.", __version__)

    def download(self):
        """
        Download applications' updates based on the last build catalog.

        Parameters
            None
        """
        self._load_config()
        _logger.info("Starting Appdownload (%s), download applications' "
                     "updates based on the last build catalog.",
                     __version__)
        self._read_catalog()
        self._fetch_update()
        self._write_catalog()
        _logger.info("Appdownload (%s) completed.", __version__)

    def make(self):
        """
        Make applist files based on the last build catalog

        Parameters
            None
        """
        self._load_config()
        _logger.info("Starting Appdownload (%s), make applist files based "
                     "on the last build catalog.", __version__)
        self._read_catalog()
        self._write_applist()
        _logger.info("Appdownload (%s) completed.", __version__)

    def test_config(self):
        """
        Check the configuration file for internal correctness.

        Parameters
            None
        """
        # The logging configuration may be not valid, events are only print on
        # the console with print(). Furthermore, the use case of this method is
        # typically in interactive mode.
        print("Starting Appdownload ({0}), check the configuration file for "
              "internal correctness.".format(__version__))
        print("Configuration details are loaded from '{0}'."
              .format(self._config_file.name))
        self._load_config()
        if self._checked_config:
            print("Configuration details are validated.")
        print("Appdownload ({0}) completed.".format(__version__))

    def _check_update(self):
        """
        Check and a_report if applications' updates are available without
         download it.


        Parameters
            None
        """
        assert self._checked_config is True

        _logger.info("Checking and a_report if applications' updates are "
                     "available.")
        # self._report = core.get_summary_header(title="Update checking",
        #                                        about="The below product have been updated")
        # self._report_toc
        # self._report_body

        for app_id in self._config[_APPS_SNAME]:
            if self._config[_APPS_SNAME].getboolean(app_id):
                _logger.debug(
                    "Load and set the '{0}' module.".format(app_id)
                )
                mod_name = self._config[app_id][_MODULE_KNAME]
                app_mod = importlib.import_module(mod_name)
                app = app_mod.Product()
                if app_id in self._catalog[_CAT_PRODUCTS_KNAME]:
                    app_entry = self._catalog[_CAT_PRODUCTS_KNAME][app_id]
                    if len(app_entry[_CAT_DEPLOYED_KNAME]) != 0:
                        app.load(app_entry[_CAT_DEPLOYED_KNAME])
                        _logger.debug("Check if an update is available")
                        origin_app = app_mod.Product()
                        origin_app.get_origin(app.version)
                        if origin_app.is_update(app):
                            msg = "A new version of '{0}' exist ({1}) " \
                                  "published on {2}."
                            _logger.info(msg.format(app_id,
                                                    origin_app.version,
                                                    origin_app.published))
                            app_entry[_CAT_ORIGIN_KNAME] = origin_app.dump()
                            self._pulling_report.add_section(origin_app.dump())
                    else:
                        msg = "The product '{0}' isn't deployed.".format(app_id)
                        _logger.info(msg.format(app_id))
                        origin_app = app_mod.Product()
                        origin_app.get_origin()
                        msg = "A version of '{0}' exist ({1}) " \
                              "published on {2}."
                        _logger.info(msg.format(app_id,
                                                origin_app.version,
                                                origin_app.published))
                        app_entry[_CAT_ORIGIN_KNAME] = origin_app.dump()
                else:
                    msg = "The product '{0}' don't exist. A new one will " \
                          "be created.".format(app_id)
                    _logger.warning(msg)
                    self._catalog[_CAT_PRODUCTS_KNAME][app_id] = {}
                    app_entry = self._catalog[_CAT_PRODUCTS_KNAME][app_id]
                    app_entry[_CAT_DEPLOYED_KNAME] = {}
                    app_entry[_CAT_ORIGIN_KNAME] = {}
                    _logger.debug("Check if an update is available")
                    origin_app = app_mod.Product()
                    origin_app.get_origin()
                    msg = "A version of '{0}' exist ({1}) " \
                          "published on {2}."
                    _logger.info(msg.format(app_id,
                                            origin_app.version,
                                            origin_app.published))
                    app_entry[_CAT_ORIGIN_KNAME] = origin_app.dump()
                    self._pulling_report.add_section(origin_app.dump())

                del app
                del origin_app
                del app_mod
                _logger.debug("'{0}' checked.".format(app_id))
            else:
                _logger.info("'{0}' ignored.".format(app_id))

        self._pulling_report.publish()

    def _fetch_update(self):
        """
        Download applications' updates based on the last build catalog.

        Parameters
            None
        """
        assert self._checked_config is True

        _logger.info("Download applications' updates based on the last "
                     "build catalog.")
        for app_id in self._config[_APPS_SNAME]:
            if self._config[_APPS_SNAME].getboolean(app_id):
                _logger.debug(
                    "Load and set the '{0}' module.".format(app_id)
                )
                mod_name = self._config[app_id][_MODULE_KNAME]
                app_mod = importlib.import_module(mod_name)
                app = app_mod.Product()
                if app_id in self._catalog[_CAT_PRODUCTS_KNAME]:
                    app_entry = self._catalog[_CAT_PRODUCTS_KNAME][app_id]
                    if len(app_entry[_CAT_ORIGIN_KNAME]) != 0:
                        app.load(app_entry[_CAT_ORIGIN_KNAME])
                        _logger.debug("Fetch the update.")
                        app.fetch(self._config[app_id][_PATH_KNAME])
                        msg = "New version of '{0}' fetched. saved as '{1}'."
                        _logger.info(msg.format(app_id, app.installer))

                        # replace the deployed product by the newest.
                        app_entry[_CAT_DEPLOYED_KNAME] = app.dump()
                        app_entry[_CAT_ORIGIN_KNAME] = {}
                        self._fetching_report.add_section(app.dump())
                    else:
                        msg = "No update for product '{0}'."
                        _logger.info(msg.format(app_id))
                else:
                    msg = "The product '{0}' don't exist. Request ignored."
                    _logger.warning(msg.format(app_id))

                del app
                del app_mod
            else:
                _logger.info("'{0}' ignored.".format(app_id))

        self._fetching_report.publish()

    def _load_config(self):
        """
        Load the configuration details from the configuration file.

        Parameters
            None
        """
        # Load the configuration, and set the logging configuration from it.
        # I'am still using the fileConfig() method instead of dictConfig() to
        # keep the configuration in a ini file, which is easy to write and to
        # read for a human.
        self._config.read_file(self._config_file)

        # Check the core section
        if _CORE_SNAME in self._config.sections():
            section = self._config[_CORE_SNAME]
            # 'store' key is mandatory
            if _STORE_KNAME in section:
                # Set the catalog filename (absolute path).
                # TODO : treat the exception for os.makedirs
                os.makedirs(
                    self._config[_CORE_SNAME][_STORE_KNAME],
                    exist_ok=True
                )
                self._catalog_filename = os.path.join(
                    self._config[_CORE_SNAME][_STORE_KNAME],
                    _CATALOG_FNAME
                )
                self._catalog_filename = os.path.abspath(self._catalog_filename)
            else:
                msg = "the key '{}' is missing in section '{}'."
                msg = msg.format(_STORE_KNAME, _CORE_SNAME)
                raise ConfigurationError(self._config_file.name, msg)

            # 'logger' key is optional
            if _LOGGER_KNAME in section:
                filename = self._config[_CORE_SNAME][_LOGGER_KNAME]
                if os.path.isfile(filename):
                    logging.config.fileConfig(filename,
                                              disable_existing_loggers=False)
                else:
                    msg = "configuration file specified in '{}' key doesn't" \
                          "exist (see section '{}')."
                    msg = msg.format(_LOGGER_KNAME, _CORE_SNAME)
                    raise ConfigurationError(self._config_file.name, msg)

            # 'pulling_report' key is optional
            if _PULL_REPORT_KNAME in section:
                filename = self._config[_CORE_SNAME][_PULL_REPORT_KNAME]
                if os.path.isfile(filename):
                    self._pulling_report = report.Report()
                    config = _load_config(filename)
                    self._pulling_report.load_config(config, False)
                else:
                    msg = "configuration file specified in '{}' key doesn't" \
                          "exist (see section '{}')."
                    msg = msg.format(_PULL_REPORT_KNAME, _CORE_SNAME)
                    raise ConfigurationError(self._config_file.name, msg)

            # 'fetching_report' key is optional
            if _FETCH_REPORT_KNAME in section:
                filename = self._config[_CORE_SNAME][_FETCH_REPORT_KNAME]
                if os.path.isfile(filename):
                    self._fetching_report = report.Report()
                    config = _load_config(filename)
                    self._fetching_report.load_config(config, False)
                else:
                    msg = "configuration file specified in '{}' key doesn't" \
                          "exist (see section '{}')."
                    msg = msg.format(_FETCH_REPORT_KNAME, _CORE_SNAME)
                    raise ConfigurationError(self._config_file.name, msg)

            # 'deploying_report' key is optional
            if _DEPLOY_REPORT_KNAME in section:
                filename = self._config[_CORE_SNAME][_DEPLOY_REPORT_KNAME]
                if os.path.isfile(filename):
                    self._deploying_report = report.Report()
                    config = _load_config(filename)
                    self._deploying_report.load_config(config, False)
                else:
                    msg = "configuration file specified in '{}' key doesn't" \
                          "exist (see section '{}')."
                    msg = msg.format(_DEPLOY_REPORT_KNAME, _CORE_SNAME)
                    raise ConfigurationError(self._config_file.name, msg)
        else:
            msg = "the section '{}' is missing.".format(_CORE_SNAME)
            raise ConfigurationError(self._config_file.name, msg)

        # Check the sets section
        if _SETS_SNAME in self._config.sections():
            sets = self._config[_SETS_SNAME]
        else:
            msg = "the section '{}' is missing.".format(_SETS_SNAME)
            raise ConfigurationError(self._config_file.name, msg)

        # Check the applications section
        if _APPS_SNAME in self._config.sections():
            for app_name in self._config[_APPS_SNAME]:
                if self._config[_APPS_SNAME].getboolean(app_name):
                    # Pre compute default value for the Application section
                    app_module = ".".join((_PACKAGE_NAME, app_name))
                    store_path = self._config[_CORE_SNAME][_STORE_KNAME]
                    app_path = os.path.join(store_path, app_name)
                    app_set = "__all__"

                    # Checks the item in the application section
                    # If a section or a key is missing, it is added in the
                    # config object, so this object will contain a complete
                    # configuration
                    if app_name in self._config.sections():
                        app_desc = self._config[app_name]
                        if _MODULE_KNAME not in app_desc:
                            app_desc[_MODULE_KNAME] = app_module
                        if _PATH_KNAME not in app_desc:
                            app_desc[_PATH_KNAME] = app_path
                        # 'set' key must be declared in the sets section if it
                        # exist.
                        if _SET_KNAME in app_desc:
                            if app_desc[_SET_KNAME] in sets:
                                pass
                            else:
                                msg = "'set' value '{}' is not declared in " \
                                      "'sets' section (see {} application)"
                                msg = msg.format(app_desc[_SET_KNAME], app_name)
                                raise ConfigurationError(self._config_file.name,
                                                         msg)
                        else:
                            app_desc[_SET_KNAME] = app_set
                    else:
                        # Set the default value
                        self._config[app_name] = {}
                        app_desc = self._config[app_name]
                        app_desc[_MODULE_KNAME] = app_module
                        app_desc[_PATH_KNAME] = app_path
                        app_desc[_SET_KNAME] = app_set
        else:
            msg = "the section '{}' is missing.".format(_APPS_SNAME)
            raise ConfigurationError(self._config_file.name, msg)

        # Checked
        self._checked_config = True
        self._config_file.close()
        self._config_file = None

    def _read_catalog(self):
        """
        Load the product's catalog.

        Parameters
            None
        """
        msg = "Load the products' catalog ({0}).".format(self._catalog_filename)
        _logger.info(msg)
        try:
            with open(self._catalog_filename, "r+t") as file:
                self._catalog = json.load(file)
        except FileNotFoundError:
            # the catalog may be not exist
            _logger.warning("The product's catalog don't exist. A new one "
                            "will be created.")
            self._catalog[_CAT_WARNING_KNAME] = _CAT_WARNING
            self._catalog[_CAT_VERSION_KNAME] = _CAT_VERSION
            self._catalog[_CAT_MODIFIED_KNAME] = ""
            self._catalog[_CAT_PRODUCTS_KNAME] = {}
        else:
            msg = "Products' catalog loaded."
            _logger.info(msg)

    def _write_catalog(self):
        """
        Write the catalog product file.

        Parameters
            None
        """
        msg = "Write the products' catalog ({0})."
        _logger.info(msg.format(self._catalog_filename))

        with open(self._catalog_filename, "w+t") as file:
            # write the warning header with a naive time representation.
            dt = (datetime.datetime.now()).replace(microsecond=0)
            self._catalog[_CAT_MODIFIED_KNAME] = dt.isoformat()
            json.dump(self._catalog, file, indent=4, sort_keys=True)
        msg = "Products' catalog saved"
        _logger.info(msg)

    def _write_applist(self):
        """
        Write the applist files from the catalog.

        Parameters
            None
        """
        _logger.info("Write the applist files from the catalog.")

        header = \
            "# --------------------------------------------------------------" \
            "----------------\n"\
            "# This applist file generated on {0} for '{1}'.\n"\
            "# This file is automatically generated, and must not be " \
            "manually modified.\n"\
            "# Please modify the configuration file instead (appdowload.ini " \
            "by default).\n"\
            "# -------------------------------------------------------------" \
            "-----------------\n"

        for app_id in self._config[_APPS_SNAME]:
            if self._config[_APPS_SNAME].getboolean(app_id):
                # build the catalog line
                app_entry = self._catalog[_CAT_PRODUCTS_KNAME][app_id]
                app_desc = app_entry[_CAT_DEPLOYED_KNAME]
                app_line = \
                    app_desc[_PROD_TARGET_KNAME] + _APPLIST_SEP + \
                    app_desc[_PROD_NAME_KNAME] + _APPLIST_SEP + \
                    app_desc[_PROD_VERSION_KNAME] + _APPLIST_SEP + \
                    app_desc[_PROD_INSTALLER_KNAME] + _APPLIST_SEP + \
                    app_desc[_PROD_SILENT_INSTALL_ARGS_KNAME]

                store_path = self._config[_CORE_SNAME][_STORE_KNAME]
                app_set_name = self._config[app_id][_SET_KNAME]
                comps = self._config[_SETS_SNAME][app_set_name]
                comp_set = comps.split(",")
                for comp_name in comp_set:
                    comp_name = comp_name.strip()
                    filename = _APPLIST_PREFIX + comp_name + _APPLIST_EXT
                    filename = os.path.join(store_path, filename)
                    if comp_name not in self._app_set_file:
                        file = open(filename, "w+t")
                        self._app_set_file[comp_name] = file
                        _logger.info(
                            "'{0}' applist file created -> '{1}'.".format(
                                comp_name, filename
                            )
                        )
                        dt = (datetime.datetime.now()).replace(microsecond=0)
                        file.write(header.format(dt.isoformat(), comp_name))
                    else:
                        file = self._app_set_file[comp_name]
                    file.write(app_line + "\n")
            else:
                _logger.info("'{0}' ignored.".format(app_id))

        # Terminate by closing the files
        for comp_name, file in self._app_set_file.items():
            file.close()


def _load_config(filename):
    """
    Load the configuration from a configuration file (see [`config.parser`]
    (https://docs.python.org/3/library/configparser.html#module-configparser)

    The configuration is stored in a dictionary with the same structure as the
    configuration file.

    :param filename: is the full path name of the configuration file.
    :return: a dictionary containing the configuration.
    """
    config = configparser.ConfigParser()
    with open(filename) as file:
        config.read_file(file)

    config_dict = {}
    for section in config.sections():
        config_dict[section] = {}
        for option in config.options(section):
            config_dict[section][option] = config.get(section, option)

    return config_dict

if __name__ == "__main__":
    # Entry point
    # Build the command line parser
    parser = argparse.ArgumentParser(
        description="Check and download applications\' updates if any.")
    general = parser.add_mutually_exclusive_group()
    general.add_argument("-c", "--checkonly", action="store_true",
                         help="check and a_report if applications' updates are "
                              "available without download it")
    general.add_argument("-d", "--download", action="store_true",
                         help="download applications' updates based on the "
                              "last build catalog (useful to recover a crashed "
                              "application storage)")
    general.add_argument("-m", "--make", action="store_true",
                         help="make applist files based on the last build "
                              "catalog (useful to make applist files after a "
                              "configuration modification)")
    general.add_argument("-t", "--testconf", action="store_true",
                         help="check an appdownload.ini configuration file for "
                              "internal correctness")
    parser.add_argument("--configfile", default="appdownload.ini",
                        type=argparse.FileType(mode='r'),
                        help="The file specified contains the configuration "
                             "details. The information in this file includes "
                             "application catalog. See appdownload.ini for "
                             "more information. The default configuration file "
                             "name is 'appdownload.ini' located in the current "
                             "working directory.")
    parser.add_argument("--version", action="version",
                        version="%(prog)s version " + __version__)

    # Parse and run.
    args = parser.parse_args()
    main_task = AppDownload(args.configfile)
    if args.checkonly:
        main_task.check()
    elif args.download:
        main_task.download()
    elif args.make:
        main_task.make()
    elif args.testconf:
        main_task.test_config()
    else:
        main_task.run()
